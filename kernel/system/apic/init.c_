// Returns 1 if the system supports APIC, 0 otherwise
uint8_t has_apic() {
  uint8_t val;

  __asm__ volatile(
      "movq 0x01, %%rax    \n\t"
      "and 0x200, %%rdx    \n\t"
      "movq %%rdx, %0"
      : "=r" (val)
      :
      : "rax", "rdx"
  );

  return !!val;
}

inline void outb(uint16_t port, uint8_t value) {
  __asm__ volatile(
      "outb %0, %1"
      :
      : "a" (value), "Nd" (port)
  );
}

#define PIC1_CMD 0x20
#define PIC1_DAT 0x21
#define PIC2_CMD 0xA0
#define PIC2_DAT 0xA1

// Disables the classic 8259 PIC
void disable_pic() {
  // Despite the fact that the IRQs will be masked, it is still
  // possible for spurious IRQs to be received on IRQ 7 and 15. For this
  // reason, we still need to remap the IRQs so we don't confuse them
  // with exceptions. Blame IBM.

  outb(PIC1_CMD, 0x11); // Init
  outb(PIC2_CMD, 0x11);

  outb(PIC1_DAT, 32); // Offset IRQs by 32
  outb(PIC2_DAT, 40);

  outb(PIC1_DAT, 4); // Inform master of slave
  outb(PIC2_DAT, 2); // Inform slave it's a slave

  outb(PIC1_DAT, 1); // Set to 8086 mode
  outb(PIC2_DAT, 1);

  // IRQs remapped
  // Now mask them

  outb(PIC2_DAT, 0xFF);
  outb(PIC1_DAT, 0xFF);
}

static inline void write_apic_reg(uint16_t reg, uint32_t val) {
  // APIC register map physical origin = 0xFEE00000
  uint32_t *reg = 0xFEE00000 + reg + PHYSICAL_MAP_OFFSET;
  *reg = val;
}

static inline uint32_t read_apic_reg(uint16_t reg) {
  // APIC register map physical origin = 0xFEE00000
  uint32_t *reg = 0xFEE00000 + reg + PHYSICAL_MAP_OFFSET;
  return *reg;
}

// Enables the APIC
void enable_apic() {
  write_apic_reg(0xF0, 0x1FF); // Enable APIC and map spurious IRQs to interrupt 255
}

// Allows the CPU to accept interrupts
void enable_interrupts() {
  __asm__ volatile("sti");
}

struct idt_entry {
  uint16_t offset_1;
  uint16_t selector;
  uint8_t ist;
  uint8_t type_attr;
  uint16_t offset_2;
  uint32_t offset_3;
  uint32_t zero;
};

extern void kb_irq();
extern void load_idt();

struct idt_entry idt[286];

void init_idt() {
  uint64_t offset = (uint64_t) kb_irq;
  idt[32].offset_1 = kb_irq & 0xffff;
  idt[32].offset_2 = (kb_irq >> 16) & 0xffff;
  idt[32].offset_3 = kb_irq >> 32;
  idt[32].selector = ; // TODO
  idt[32].ist = 0;
  idt[32].type_attr = 0x8E;
  idt[32].zero = 0;

  uint64_t idt_ptr[2];

  idt_ptr[0] = (256 * sizeof idt[0]) + (((uint64_t) idt & 0xffff) << 16);
  idt_ptr[1] = ((uint64_t) idt) >> 16;

  load_idt(idt_ptr);

  load_idt(idt_ptr);
}

